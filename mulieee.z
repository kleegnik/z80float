; IEEE floating-point multiplication

	org 0

start:
	ld sp,2048
	di

	call mulieee
	halt

; multiplicand in HLDE, multiplier in H'L'D'E'
mulieee:
	ld a,h
	rl l
	rla
	push af			; save exponent, and sign in carry
	scf
	rr l				; set implied bit 23; multiplicand fraction in LDE
	exx
	ld a,h
	rl l
	rla
	push af
	scf
	rr l				; set implied bit 23; multiplier fraction in L'D'E'
	exx

	pop af
	rr c				; store sign in bit 7 of C
	ld b,a
	pop af
	rr c				; signs now in bits 6 and 7 of C
	add a,b			; exponent sum
	sub 127			; subtract extra bias (allowable range is: -126 .. +127)
	ld b,a
	ld a,c
	rla
	xor c
	rla
	push af			; store final sign in carry
	push bc			; store provisional exponent from B

; fractions stored in 24 bits: LDE x L'D'E'
	exx
	ld a,l
	ld hl,0
	exx
	ld c,l
	ld h,d
	ld l,e		; multiplier to CHL
	ld e,a		; multiplicand to ED'E'
	xor a			; result (top 24 bits) in AH'L'
	ld b,25
	jr mul24sh	; need to shift multiplier first (carry is clear)

mul24lp:
	jr nc,mul24noadd
	exx
	add hl,de
	exx
	adc a,e		; add multiplicand to result
mul24noadd:
	rra
	exx
	rr h
	rr l
	exx			; immediately shift the result right (over 24 bits, which produces top 24 bits in AH'L')
mul24sh:
	rr c
	rr h
	rr l			; shift multiplier right, taking in carry from shifted result (over 24 bits, which produces bottom 24 bits of result in CHL)
	djnz mul24lp

; full 48-bit product is now in AH'L'CHL
	pop de				
	ld b,d				; exponent to B
	exx
	push hl
	exx
	pop hl				; top 32 bits of product to AHLC

; The binary point is now two places to the right of the top bit,
; i.e. between bits 22 and 21:
; product = 01.xxx.., 10.xxx.. or 11.xxx.. (instead of 1.xxxx..)
; e.g. 1.1 * 1.1 = 10.01 (1.5 * 1.5 = 2.25)
;      1.111 * 1.111 = 11.10.. (1.875 * 1.875 = 3.515..)
; and  1.0 * 1.0 = 01.00 (1.0 * 1.0 = 1.0)
; - so we leave the fraction as it is and increment the exponent to compensate.
	inc b

normalise:				; over 32 bits
	or a
	jp m,repack			; top bit set - finished
	sla c
	adc hl,hl
	rla
	dec b
	jr nz,normalise

; exponent decremented to zero, so underflow -> truncate to zero
	ld c,b
	ld l,b
	ld h,b

; should round from lower 8 bits (i.e. bit 7 of C)
; - will truncate for now
repack:
	ld e,l
	ld d,h
	ld l,a				; transfer fraction to LDE
	ld h,b				; exponent to H
	rl l
	pop af				; retrieve sign of result
	rr h
	rr l

	ret					; finished: result in HLDE
