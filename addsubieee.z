	org 0

	di
	ld sp,2048

; float operands in HLDE and H'L'D'E'
; operator (+/-) in C
	jr start


; op  A  B   result (using absolute values of A and B)
; +   +  +    A+B
; +   -  -   -(A+B)
; +   -  +   -(A-B)  $ *
; +   +  -    A-B    $ *
; -   +  +    A-B    $
; -   -  -    -(A-B) $
; -   -  +    -(A+B)   *
; -   +  -    A+B      *
;
; $ = sign changed when operands are exchanged
; * = operation (+/-) exchanged

FLADDSUB: defb 0

start:
	ld a,c
	ld (FLADDSUB),a		; 0/1 = addition/subtraction

	ld a,h
	rl l
	rla
	push af			; save exponent, and sign in carry
	scf
	rr l				; set implied bit 23
	ld b,l
	push de

	exx
	ld a,h
	rl l
	rla
	ex af,af'		; save exponent, and sign in carry
	scf
	ld a,l
	rra				; set implied bit 23
	pop hl
	exx
	ld c,a			; fraction1 in BH'L', fraction2 in CD'E'

	ex af,af'
	rl l				; store sign2 in bit 0 of L
	ld h,a			; store exp2 in H
	pop af
	push af			; restack sign of first operand in carry (provisional sign of result)
	ld d,a			; store exp1 in D
	rla				; get sign1 into bit 0 of A
	xor l
	ld l,a			; store sign difference in bit 0 of L

	ld a,d
	sub h				; compare exponents
	jr z,noshift
	jr nc,noexpswap

; swap operands
	ex af,af'		; save exponent difference
	exx
	ex de,hl			; swap bits 0..15 of fractions
	exx
	ld a,b
	ld b,c
	ld c,a			; swap bits 16..23 of fractions
	ld a,d
	ld d,h
	ld h,a			; swap exponents

; swap sign if:
; for addition - signs are different
; for subtraction - signs are the same
	ld a,(FLADDSUB)
	xor l
	rra
	jr nc,nexp
	pop af
	ccf				; change sign of result
	push af
nexp:
	ex af,af'
	neg				; negate exponent difference

noexpswap:
	cp 24
	jr c,shiftfrac2
; exponent difference too large; use first operand as result
	exx
	push hl
	exx
	pop hl
	jr repack		; finish with fraction from BHL

; shift fraction2 right until exponents match
shiftfrac2:
	srl c
	exx
	rr d
	rr e
	exx
	dec a
	jr nz,shiftfrac2

noshift:
	ld a,(FLADDSUB)	; get add/sub flag (0/1)
	xor l					; change operation if signs are different
	ld (FLADDSUB),a
	rra
	exx
	jr c,flsub
	add hl,de
	exx
	ld a,b
	adc a,c
	ld b,a				; add two fractions
	jr checkbit24
flsub:
	or a
	sbc hl,de
	exx
	ld a,b
	sbc a,c				; subtract two fractions
	ld b,a

checkbit24:
	exx
	push hl
	exx
	pop hl				; result fraction to BHL
	jr nc,checknorm	; neither overflow (addtion) nor negative (subtraction) fraction
	ld a,(FLADDSUB)
	rra
	jr c,fracneg
; overflow after addition requires shifting fraction right and incrementing exponent
	srl b
	rr h
	rr l					; rounding maybe?
	inc d
	jr repack

fracneg:
; negative fraction after subtraction requires negating fraction and change of sign
	ld a,l
	neg					; clears carry on negating 0; sets otherwise
	ccf
	ld l,a
	ld a,h
	cpl
	adc a,0
	ld h,a
	ld a,b
	cpl
	adc a,0
	ld b,a
	pop af
	ccf
	push af
	jr checknorm2

checknorm:
; check if fraction is zero first (from subtraction)
	ld a,b
	or h
	or l
	jr nz,checknorm2
	ld d,a
	ld e,a
	pop af
	halt					; finish, with everything (HLDE) zero = 0

checknorm2:
	ld a,(FLADDSUB)
	rra
	jr nc,repack		; only need to normalise after subtraction

normalise:
	bit 7,b
	jr nz,repack
	add hl,hl
	rl b
	dec d
	jr normalise

repack:
; from D,BHL
	ex de,hl
	rl b
	pop af				; retrieve sign of result
	rr h
	rr b
	ld l,b
	halt					; finished: result in HLDE
